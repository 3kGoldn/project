# -*- coding: utf-8 -*-
"""“InstantMesh_jupyter.ipynb”的副本

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pX0KH507rI7JGqMwBumgrp6rOYEVWBMP
"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content

!GIT_LFS_SKIP_SMUDGE=1 git clone -b dev https://github.com/camenduru/InstantMesh

# %cd /content/InstantMesh

!pip install pytorch-lightning==2.1.2 gradio==3.50.2 einops omegaconf torchmetrics webdataset accelerate tensorboard

!pip install PyMCubes trimesh rembg transformers diffusers==0.33.1 bitsandbytes imageio[ffmpeg] xatlas plyfile

!pip install git+https://github.com/NVlabs/nvdiffrast jax==0.6.0 jaxlib==0.6.0 ninja

!pip install onnxruntime

!pip install --upgrade huggingface_hub==0.30.2

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/InstantMesh

import torch
model = None
torch.cuda.empty_cache()

import numpy as np
import rembg
from PIL import Image
from pytorch_lightning import seed_everything
from einops import rearrange
from diffusers import DiffusionPipeline, EulerAncestralDiscreteScheduler
from huggingface_hub import hf_hub_download
from src.utils.infer_util import remove_background, resize_foreground
from google.colab import files
import os

# 初始化pipeline
pipeline = DiffusionPipeline.from_pretrained("sudo-ai/zero123plus-v1.2", custom_pipeline="zero123plus", torch_dtype=torch.float16)
pipeline.scheduler = EulerAncestralDiscreteScheduler.from_config(pipeline.scheduler.config, timestep_spacing='trailing')
unet_ckpt_path = hf_hub_download(repo_id="TencentARC/InstantMesh", filename="diffusion_pytorch_model.bin", repo_type="model")
state_dict = torch.load(unet_ckpt_path, map_location='cpu')
pipeline.unet.load_state_dict(state_dict, strict=True)
device = torch.device('cuda')
pipeline = pipeline.to(device)
seed_everything(0)

def preprocess(input_image, do_remove_background):
    rembg_session = rembg.new_session() if do_remove_background else None
    if do_remove_background:
        input_image = remove_background(input_image, rembg_session)
        input_image = resize_foreground(input_image, 0.85)
    return input_image

def generate_six_views(input_image, sample_steps, sample_seed, output_dir):
    """生成6张新视角图并保存到指定目录"""
    seed_everything(sample_seed)
    generator = torch.Generator(device=device)

    # 生成6视角拼接图 (960x640, 包含6张小图)
    z123_image = pipeline(
        input_image,
        num_inference_steps=sample_steps,
        generator=generator,
    ).images[0]

    # 转换为NumPy数组并分割成6张独立图像
    images_array = np.array(z123_image)  # (960, 640, 3)
    images_tensor = torch.from_numpy(images_array)

    # 分割成6张320x320的图 (按3行2列排列)
    single_images = rearrange(images_tensor, '(n h) (m w) c -> (n m) h w c', n=3, m=2, h=320, w=320)

    # 创建输出目录
    os.makedirs(output_dir, exist_ok=True)

    # 保存6张视角图，命名格式: view_{index}.png
    view_names = ['front', 'front_right', 'right', 'back', 'left', 'front_left']
    for idx, img in enumerate(single_images):
        img_pil = Image.fromarray(img.numpy())
        img_pil.save(f"{output_dir}/{view_names[idx]}.png")

    # 同时保存拼接图 (2x3布局)
    composite = rearrange(single_images, '(n m) h w c -> (n h) (m w) c', n=2, m=3)
    composite_pil = Image.fromarray(composite.numpy())
    composite_pil.save(f"{output_dir}/composite.png")

    return single_images, composite_pil

# 1. 处理主视图 → 生成6张新视角图
print("=== 第一步：请上传主视图 ===")
uploaded = files.upload()
input_image = Image.open(list(uploaded.keys())[0])
processed_image = preprocess(input_image, do_remove_background=True)
print("主视图预处理结果:")
display(processed_image)

# 生成6张视角图（保存到 /outputs/main_views/）
os.makedirs("/content/InstantMesh/outputs/main_views", exist_ok=True)
single_images_main, composite_main = generate_six_views(processed_image, 75, 42, "/content/InstantMesh/outputs/main_views")
print("✅ 主视图生成的6张视角图已保存到 /outputs/main_views/")
print("2×3拼接预览图:")
display(composite_main)

# 2. 处理侧视图 → 生成6张新视角图
print("\n=== 第二步：请上传侧视图 ===")
uploaded = files.upload()
input_image = Image.open(list(uploaded.keys())[0])
processed_image = preprocess(input_image, do_remove_background=True)
print("侧视图预处理结果:")
display(processed_image)

# 生成6张视角图（保存到 /outputs/side_views/）
os.makedirs("/content/InstantMesh/outputs/side_views", exist_ok=True)
single_images_side, composite_side = generate_six_views(processed_image, 75, 42, "/content/InstantMesh/outputs/side_views")
print("✅ 侧视图生成的6张视角图已保存到 /outputs/side_views/")
print("2×3拼接预览图:")
display(composite_side)

# 3. 处理背视图 → 生成6张新视角图
print("\n=== 第三步：请上传背视图 ===")
uploaded = files.upload()
input_image = Image.open(list(uploaded.keys())[0])
processed_image = preprocess(input_image, do_remove_background=True)
print("背视图预处理结果:")
display(processed_image)

# 生成6张视角图（保存到 /outputs/back_views/）
os.makedirs("/content/InstantMesh/outputs/back_views", exist_ok=True)
single_images_back, composite_back = generate_six_views(processed_image, 75, 42, "/content/InstantMesh/outputs/back_views")
print("✅ 背视图生成的6张视角图已保存到 /outputs/back_views/")
print("2×3拼接预览图:")
display(composite_back)

print("\n=== 生成完成！ ===")
print("总计生成 18 张视角图：")
print("- 主视图 → 6张 → /outputs/main_views/")
print("- 侧视图 → 6张 → /outputs/side_views/")
print("- 背视图 → 6张 → /outputs/back_views/")

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/InstantMesh

import torch

pipeline = None

torch.cuda.empty_cache()

import os

from torchvision.transforms import v2

from huggingface_hub import hf_hub_download

from omegaconf import OmegaConf

from PIL import Image

import numpy as np

from einops import rearrange, repeat

import tempfile

from tqdm import tqdm

import imageio

from src.utils.train_util import instantiate_from_config

from src.utils.camera_util import (FOV_to_intrinsics, get_zero123plus_input_cameras,get_circular_camera_poses,)

from src.utils.mesh_util import save_obj, save_obj_with_mtl

config_path = 'configs/instant-mesh-base.yaml'

config = OmegaConf.load(config_path)

config_name = os.path.basename(config_path).replace('.yaml', '')

model_config = config.model_config

infer_config = config.infer_config

model_ckpt_path = hf_hub_download(repo_id="TencentARC/InstantMesh", filename="instant_mesh_base.ckpt", repo_type="model")

model = instantiate_from_config(model_config)

state_dict = torch.load(model_ckpt_path, map_location='cpu')['state_dict']

state_dict = {k[14:]: v for k, v in state_dict.items() if k.startswith('lrm_generator.') and 'source_camera' not in k}

model.load_state_dict(state_dict, strict=True)

device = torch.device('cuda')

model = model.to(device)

IS_FLEXICUBES = True if config_name.startswith('instant-mesh') else False

if IS_FLEXICUBES: model.init_flexicubes_geometry(device, fovy=30.0)

model = model.eval()

def images_to_video(images, output_path, fps=30): os.makedirs(os.path.dirname(output_path), exist_ok=True) frames = [] for i in range(images.shape[0]): frame = (images[i].permute(1, 2, 0).cpu().numpy() * 255).astype(np.uint8).clip(0, 255) assert frame.shape[0] == images.shape[2] and frame.shape[1] == images.shape[3], \ f"Frame shape mismatch: {frame.shape} vs {images.shape}" assert frame.min() >= 0 and frame.max() <= 255, \ f"Frame value out of range: {frame.min()} ~ {frame.max()}" frames.append(frame) imageio.mimwrite(output_path, np.stack(frames), fps=fps, codec='h264')

def get_render_cameras(batch_size=1, M=120, radius=2.5, elevation=10.0, is_flexicubes=False): c2ws = get_circular_camera_poses(M=M, radius=radius, elevation=elevation) if is_flexicubes: cameras = torch.linalg.inv(c2ws) cameras = cameras.unsqueeze(0).repeat(batch_size, 1, 1, 1) else: extrinsics = c2ws.flatten(-2) intrinsics = FOV_to_intrinsics(30.0).unsqueeze(0).repeat(M, 1, 1).float().flatten(-2) cameras = torch.cat([extrinsics, intrinsics], dim=-1) cameras = cameras.unsqueeze(0).repeat(batch_size, 1, 1) return cameras

def make_mesh(mesh_fpath, planes): mesh_basename = os.path.basename(mesh_fpath).split('.')[0] mesh_dirname = os.path.dirname(mesh_fpath) mesh_vis_fpath = os.path.join(mesh_dirname, f"{mesh_basename}.glb") with torch.no_grad(): mesh_out = model.extract_mesh(planes, use_texture_map=True, **infer_config,) vertices, faces, uvs, mesh_tex_idx, tex_map = mesh_out # vertices = vertices[:, [1, 2, 0]] # vertices[:, -1] *= -1 # faces = faces[:, [2, 1, 0]] save_obj_with_mtl( vertices.data.cpu().numpy(), uvs.data.cpu().numpy(), faces.data.cpu().numpy(), mesh_tex_idx.data.cpu().numpy(), tex_map.permute(1, 2, 0).data.cpu().numpy(), mesh_fpath, ) print(f"Mesh with texmap saved to {mesh_fpath}") # vertices, faces, vertex_colors = mesh_out # vertices = vertices[:, [1, 2, 0]] # vertices[:, -1] *= -1 # faces = faces[:, [2, 1, 0]] # save_obj(vertices, faces, vertex_colors, mesh_fpath) # print(f"Mesh saved to {mesh_fpath}") return mesh_fpath

def make3d(images): images = np.asarray(images, dtype=np.float32) / 255.0 images = torch.from_numpy(images).permute(2, 0, 1).contiguous().float() # (3, 960, 640) images = rearrange(images, 'c (n h) (m w) -> (n m) c h w', n=3, m=2) # (6, 3, 320, 320) input_cameras = get_zero123plus_input_cameras(batch_size=1, radius=4.0).to(device) render_cameras = get_render_cameras( batch_size=1, radius=4.5, elevation=20.0, is_flexicubes=IS_FLEXICUBES).to(device) images = images.unsqueeze(0).to(device) images = v2.functional.resize(images, (320, 320), interpolation=3, antialias=True).clamp(0, 1) directory = '/content/tmp' if not os.path.exists(directory): os.makedirs(directory) tempfile.tempdir = directory mesh_fpath = tempfile.NamedTemporaryFile(suffix=f".obj", delete=False).name print(mesh_fpath) mesh_basename = os.path.basename(mesh_fpath).split('.')[0] mesh_dirname = os.path.dirname(mesh_fpath) video_fpath = os.path.join(mesh_dirname, f"{mesh_basename}.mp4") with torch.no_grad(): planes = model.forward_planes(images, input_cameras) chunk_size = 20 if IS_FLEXICUBES else 1 render_size = 384 frames = [] for i in tqdm(range(0, render_cameras.shape[1], chunk_size)): if IS_FLEXICUBES: frame = model.forward_geometry(planes, render_cameras[:, i:i+chunk_size], render_size=render_size,)['img'] else: frame = model.synthesizer(planes, cameras=render_cameras[:, i:i+chunk_size],render_size=render_size,)['images_rgb'] frames.append(frame) frames = torch.cat(frames, dim=1) images_to_video(frames[0], video_fpath, fps=30,) print(f"Video saved to {video_fpath}") mesh_fpath = make_mesh(mesh_fpath, planes) return video_fpath, mesh_fpath

mv_images = Image.open('/content/InstantMesh/mv_images.png')

output_video, output_model_obj = make3d(mv_images)

!cp -f {output_video} /content/InstantMesh/output_video.mp4

!cp -f {output_model_obj} /content/InstantMesh/output_model.obj

from IPython.display import Video

Video(output_video, embed=True)